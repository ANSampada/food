1. Class and Objects
Example from your file:
class Job:
    def __init__(self, name, template, **kwargs):
        template_dir = os.path.join(os.path.dirname(__file__), "templetes")
        env = Environment(loader=FileSystemLoader(template_dir))
        
        tmpl = env.get_template(template)
        self.name = name
        self.config = tmpl.render(**kwargs)


class Job:
A class is like a blueprint.
Here, Job is a blueprint for Jenkins jobs. It says what information (data) and behaviors (functions) a "Job" should have.

def __init__:
This is called a constructor. It runs automatically when you create an object.

name and template are required inputs.

**kwargs means "accept any number of extra named inputs".

self:
This means "the object itself". Every object keeps its own copy of data.

Inside __init__:
It sets:

self.name = name → the object remembers its job name.

self.config = tmpl.render(**kwargs) → it generates job configuration.

Object (Instance)

In main.py:

curry = Job(
    "Recipes/curry",
    "freestyle_template.j2.xml",
    description="Curry build job",
    ...
)


curry is an object (also called instance) of the Job class.

Think of class Job like a recipe book, and curry is a dish cooked from that recipe.

You can make many objects (chapati, samosa, parata) from the same class.

2. Functions (Methods)

In Python, functions are defined with def.

Example:

def get_jenkins():
    return jenkins.Jenkins(JENKINS_URL, username=USERNAME, password=PASSWORD)


A function is a reusable block of code.

get_jenkins() always gives you a Jenkins server connection.

When a function belongs to a class, it’s called a method.
When it stands alone (like in update.py), it’s just a normal function.

3. Modules

Each .py file is called a module.

jobs.py defines the Job class.

update.py has functions to connect to Jenkins.

main.py brings everything together.

You import one module into another using import.
Example:

from jobs import Job


This means → “use the Job class from jobs.py”.

4. Packages

If you put multiple Python files in a folder with __init__.py, that folder becomes a package.
Here, you don’t have one, but if you grouped jobs.py, update.py, etc., into a folder, it could be a package.

5. Control Flow (Loops, If-Else)

Example:

for recipe in ["chapati", "samosa", "parata"]:
    job = Job(
        f"Recipes/{recipe}",
        "pipeline_template.j2.xml",
        ...
    )
    update_job(job)


for → loop through items in a list.

It creates three objects (chapati, samosa, parata) one by one.

Example of if:

if not server.job_exists(folder_name):
    server.create_job(folder_name, FOLDER_XML)


If the folder doesn’t exist, create it. Otherwise, skip.

6. Strings and f-Strings
f"Recipes/{recipe}"


This is an f-string → it allows you to insert variables directly into strings.
If recipe = "chapati", it becomes "Recipes/chapati".

7. Modules from Outside (Libraries)

import os → Python’s built-in module for handling files & paths.

import jenkins → external library to talk to Jenkins.

from jinja2 import Environment, FileSystemLoader → template engine for generating XML configs.

8. Putting It All Together (Workflow)

main.py runs first.
It connects to Jenkins (get_jenkins), ensures a folder exists (ensure_folder), then creates jobs (Job objects).

jobs.py defines Job class.
Each job object builds its configuration.

update.py updates Jenkins.
It either creates a new job or updates an old one.

✅ In short:

Class = blueprint (Job).

Object/Instance = real thing created from class (curry, chapati).

self = tells each object to keep its own data.

Functions = reusable tasks (some inside classes, some outside).

Modules = files with Python code.

Control flow = decisions (if) + repetition (for).
---------------------------------------------------------------------------------------------------------------
Here’s a visual diagram showing how your three files (main.py, jobs.py, update.py) work together:

main.py is the controller: it calls everything.

jobs.py defines the Job class (blueprint).

update.py defines functions (update_job, ensure_folder, get_jenkins) to talk to Jenkins.

main.py creates job objects from Job class and then calls functions in update.py to create/update them in Jenkins.
-------------------------------------------------------------------------------------------------------------------
Start – You execute main.py.

Connect to Jenkins – Uses get_jenkins() to log into Jenkins.

Ensure Folder – Calls ensure_folder() to check if "Recipes" folder exists; if not, creates it.

Create Curry Job – Makes a Job object for Curry using the Job class.

Send Curry Job – Calls update_job() to create/update Curry in Jenkins.

Loop for Chapati, Samosa, Parata – For each one:

Create a Job object

Send it to Jenkins

End – All jobs are created/updated. ✅
-----------------------------------------------------------------------------------------------------------
Great 😃 Let’s use a real-world cooking analogy for your Python + Jenkins example.

🥘 Cooking Analogy for main.py, jobs.py, update.py
1. The Recipe Book (Class)

class Job in jobs.py = a recipe book.

It explains how to cook a dish: what ingredients it needs (name, template, etc.) and how to prepare it (__init__).

👉 But a recipe book by itself doesn’t make food — it just tells you how.

2. The Dishes (Objects / Instances)

When you do:

curry = Job("Recipes/curry", "freestyle_template.j2.xml", ...)


It’s like saying: “Okay, let’s cook Curry using the recipe.”

Now you have a real dish of Curry, not just the recipe.

Similarly, you create Chapati, Samosa, Parata using the same recipe style (class).

👉 Every dish is an object, cooked from the same recipe (class).

3. The Kitchen (Jenkins Server)

Jenkins is your kitchen where cooking actually happens.

get_jenkins() = walking into the kitchen and turning on the stove.

4. The Kitchen Shelf (Folder)

ensure_folder(server, "Recipes") = making sure you have a shelf in the kitchen named “Recipes” to store your dishes.

If the shelf doesn’t exist, you build it.

If it already exists, you just use it.

5. Placing the Dish on the Shelf (update_job)

Once a dish (job object) is ready, you put it on the “Recipes” shelf:

update_job(curry)


If Curry is already on the shelf, you replace it with a fresh version (update).

If not, you place it there for the first time (create).

6. Repeating for All Dishes

The for recipe in ["chapati", "samosa", "parata"]: loop = telling the chef:
“Now cook Chapati, then Samosa, then Parata — and place each on the Recipes shelf.”

✅ In Simple Words:

jobs.py (Recipe Book) → Defines how to make a dish (Job).

main.py (Chef) → Orders which dishes to cook (Curry, Chapati, etc.).

update.py (Kitchen Helpers) → Handles the kitchen (Jenkins), shelves (folders), and placing dishes (jobs).

So running main.py = telling the chef to prepare a bunch of dishes and neatly arrange them in the kitchen shelf. 🍛
